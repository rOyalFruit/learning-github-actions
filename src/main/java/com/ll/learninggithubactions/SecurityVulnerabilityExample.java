package com.ll.learninggithubactions;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.security.MessageDigest;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.Base64;
import java.util.Random;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

public class SecurityVulnerabilityExample {

	// 1. 하드코딩된 비밀번호 (CWE-798)
	private static final String HARD_CODED_PASSWORD = "password123";
	private static final String DATABASE_URL = "jdbc:mysql://localhost:3306/test";
	private static final String DATABASE_USER = "admin";
	private static final String DATABASE_PASSWORD = "admin123"; // 하드코딩된 또 다른 비밀번호

	// 2. 약한 암호화 알고리즘 사용 (CWE-327)
	public String encryptWeakly(String data) throws Exception {
		// DES는 약한 암호화 알고리즘으로 간주됩니다
		Cipher cipher = Cipher.getInstance("DES/ECB/PKCS5Padding");
		SecretKeySpec keySpec = new SecretKeySpec(HARD_CODED_PASSWORD.getBytes(), 0, 8, "DES");
		cipher.init(Cipher.ENCRYPT_MODE, keySpec);
		byte[] encrypted = cipher.doFinal(data.getBytes());
		return Base64.getEncoder().encodeToString(encrypted);
	}

	// 3. 약한 해시 알고리즘 사용 (CWE-328)
	public String hashWeakly(String password) throws Exception {
		// MD5는 약한 해시 알고리즘으로 간주됩니다
		MessageDigest md = MessageDigest.getInstance("MD5");
		byte[] digest = md.digest(password.getBytes());
		StringBuilder sb = new StringBuilder();
		for (byte b : digest) {
			sb.append(String.format("%02x", b));
		}
		return sb.toString();
	}

	// 4. SQL 인젝션 취약점 (CWE-89)
	public ResultSet sqlInjectionVulnerability(String username, String password) {
		ResultSet rs = null;
		try {
			Connection conn = DriverManager.getConnection(DATABASE_URL, DATABASE_USER, DATABASE_PASSWORD);
			Statement stmt = conn.createStatement();

			// 사용자 입력을 직접 SQL 쿼리에 삽입 - SQL 인젝션 취약점
			String query = "SELECT * FROM users WHERE username = '" + username + "' AND password = '" + password + "'";
			rs = stmt.executeQuery(query);

			// 연결을 닫지 않음 - 리소스 누수 (CWE-772)
		} catch (Exception e) {
			e.printStackTrace();
		}
		return rs;
	}

	// 5. 명령어 인젝션 취약점 (CWE-78)
	public void commandInjectionVulnerability(String userInput) {
		try {
			// 사용자 입력을 검증하지 않고 시스템 명령어로 실행
			Runtime.getRuntime().exec("ping " + userInput);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	// 6. XSS 취약점 (CWE-79)
	public void xssVulnerability(HttpServletRequest request, HttpServletResponse response) throws IOException {
		String userInput = request.getParameter("comment");
		// 사용자 입력을 검증하거나 이스케이프하지 않고 HTML에 삽입
		response.getWriter().println("<div>" + userInput + "</div>");
	}

	// 7. 안전하지 않은 난수 생성 (CWE-330)
	public String generateInsecureToken() {
		// java.util.Random은 암호학적으로 안전하지 않은 난수 생성기입니다
		Random random = new Random();
		StringBuilder token = new StringBuilder();
		for (int i = 0; i < 10; i++) {
			token.append(random.nextInt(10));
		}
		return token.toString();
	}

	// 8. 경로 순회 취약점 (CWE-22)
	public byte[] pathTraversalVulnerability(String fileName) {
		try {
			// 사용자 입력을 검증하지 않고 파일 경로에 사용
			File file = new File("/safe/directory/" + fileName);
			return Files.readAllBytes(file.toPath());
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}

	// 9. 안전하지 않은 직렬화 (CWE-502)
	public Object unsafeDeserialization(String serializedData) {
		try {
			// 사용자 입력을 검증하지 않고 역직렬화
			byte[] data = Base64.getDecoder().decode(serializedData);
			java.io.ObjectInputStream ois = new java.io.ObjectInputStream(new java.io.ByteArrayInputStream(data));
			return ois.readObject();
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}

	// 10. 안전하지 않은 임시 파일 생성 (CWE-377)
	public File createUnsafeTempFile(String content) {
		try {
			// 예측 가능한 이름으로 임시 파일 생성
			File tempFile = new File("/tmp/temp-" + System.currentTimeMillis() + ".txt");
			FileOutputStream fos = new FileOutputStream(tempFile);
			fos.write(content.getBytes());
			fos.close();
			return tempFile;
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}

	// 11. 취약한 암호화 모드 사용 (CWE-327)
	public byte[] encryptWithECBMode(String data, String key) throws Exception {
		// ECB 모드는 안전하지 않은 암호화 모드입니다
		Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
		SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(), "AES");
		cipher.init(Cipher.ENCRYPT_MODE, keySpec);
		return cipher.doFinal(data.getBytes());
	}

	// 12. 안전하지 않은 해시 저장 (CWE-916)
	public String hashPasswordUnsafely(String password) throws Exception {
		// 솔트 없이 해시 저장
		MessageDigest md = MessageDigest.getInstance("SHA-256");
		byte[] digest = md.digest(password.getBytes());
		StringBuilder sb = new StringBuilder();
		for (byte b : digest) {
			sb.append(String.format("%02x", b));
		}
		return sb.toString();
	}

	// 13. 안전하지 않은 권한 체크 (CWE-285)
	public boolean unsafePermissionCheck(String username, String requestedFile) {
		// 부적절한 권한 검사
		if (username != null && !username.isEmpty()) {
			return true; // 사용자 이름만 있으면 모든 파일에 접근 가능
		}
		return false;
	}

	// 14. 안전하지 않은 리다이렉트 (CWE-601)
	public void unsafeRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {
		String url = request.getParameter("url");
		// 사용자 입력을 검증하지 않고 리다이렉트
		response.sendRedirect(url);
	}

	// 15. 안전하지 않은 정규식 (CWE-1333)
	public boolean validateEmailUnsafely(String email) {
		// 취약한 정규식 패턴 (ReDoS 취약점)
		return email.matches(
			"^([a-zA-Z0-9_\\-\\.]+)@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.)|(([a-zA-Z0-9\\-]+\\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\\]?)$");
	}
}