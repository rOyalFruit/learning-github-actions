package com.ll.learninggithubactions;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;
import java.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public class SecurityVulnerabilityExample {

	// 하드코딩된 비밀번호 (CWE-798)
	private static final String HARD_CODED_PASSWORD = "password123";

	// 약한 암호화 알고리즘 사용 (CWE-327)
	public String encryptWeakly(String data) throws Exception {
		// DES는 약한 암호화 알고리즘으로 간주됩니다
		Cipher cipher = Cipher.getInstance("DES");
		SecretKeySpec keySpec = new SecretKeySpec(HARD_CODED_PASSWORD.getBytes(), 0, 8, "DES");
		cipher.init(Cipher.ENCRYPT_MODE, keySpec);
		byte[] encrypted = cipher.doFinal(data.getBytes());
		return Base64.getEncoder().encodeToString(encrypted);
	}

	// SQL 인젝션 취약점 (CWE-89)
	public void sqlInjectionVulnerability(String userInput) {
		try {
			Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/test", "user", "password");
			Statement stmt = conn.createStatement();

			// 사용자 입력을 직접 SQL 쿼리에 삽입 - SQL 인젝션 취약점
			String query = "SELECT * FROM users WHERE username = '" + userInput + "'";
			stmt.executeQuery(query);

			conn.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	// XSS 취약점 (CWE-79)
	public String xssVulnerability(String userInput) {
		// 사용자 입력을 검증하거나 이스케이프하지 않고 HTML에 삽입
		return "<div>" + userInput + "</div>";
	}

	// 안전하지 않은 난수 생성 (CWE-330)
	public int generateInsecureRandom() {
		// java.util.Random은 암호학적으로 안전하지 않은 난수 생성기입니다
		java.util.Random random = new java.util.Random();
		return random.nextInt();
	}

	// 경로 순회 취약점 (CWE-22)
	public void pathTraversalVulnerability(String fileName) {
		try {
			// 사용자 입력을 검증하지 않고 파일 경로에 사용
			java.io.File file = new java.io.File("/safe/directory/" + fileName);
			java.io.FileInputStream fis = new java.io.FileInputStream(file);
			fis.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}